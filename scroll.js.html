<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width">
    <meta name="format-detection" content="telephone=no">
    <!-- iOS私有属性 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <!-- 启用360浏览器的极速模式(webkit) -->
    <meta name="renderer" content="webkit">
    <!-- 避免IE使用兼容模式 -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->
    <meta name="HandheldFriendly" content="true">
    <!-- 微软的老式浏览器 -->
    <meta name="MobileOptimized" content="320">
    <!-- uc强制竖屏 -->
    <meta name="screen-orientation" content="portrait">
    <!-- QQ强制竖屏 -->
    <meta name="x5-orientation" content="portrait">
    <!-- UC强制全屏 -->
    <meta name="full-screen" content="yes">
    <!-- QQ强制全屏 -->
    <meta name="x5-fullscreen" content="true">
    <!-- UC应用模式 -->
    <meta name="browsermode" content="application">
    <!-- QQ应用模式 -->
    <meta name="x5-page-mode" content="app">
    <!-- windows phone 点击无高光 -->
    <meta name="msapplication-tap-highlight" content="no">

    <title>Demo of Scroll.js</title>
    <style>
    html,
    body {
        height: 100%;
        padding: 0;
        margin: 0;
        border: 0;
    }

    .scroll-wrap {
        position: relative;
        height: 100%;
        border: 1px solid #000;
        overflow: hidden;
    }

    .test-div {
        height: 256px;
        line-height: 64px;
        font-size: 32px;
        border: 1px solid #666;
    }
    </style>
    <script>
    var choice = 0; // 0: transform, 1: top
    var scrollPosition = 0;
    var scrollStyle = null;

    var test_addScrollContent = function() {
        var div1 = document.getElementById('div1');
        for (var i = 0; i < 1000; i++) {
            var child = document.createElement('div');
            child.className = 'test-div';
            child.innerHTML = i;
            div1.appendChild(child);
        }
    };

    var swipeDetect = function(el, callback) {
        var page = el,
            startX,
            startY,
            startTop,
            thenX, thenY, nowX, nowY,
            lastMoveTime,
            lastLastMoveTime,
            distX,
            distY,
            threshold = 150, //required min distance traveled to be considered swipe
            restraint = 100, // maximum distance allowed at the same time in perpendicular direction
            allowedTime = 300, // maximum time allowed to travel that distance
            thresholdTime = 100,
            acceleration = 2000,
            startTime,
            handleswipe = callback || function() {};

        page.addEventListener('touchstart', function(e) {
            var touchobj = e.changedTouches[0];
            thenX = nowX = startX = touchobj.pageX;
            thenY = nowY = startY = touchobj.pageY;
            startTime = lastLastMoveTime = lastMoveTime = Date.now();
            startTop = scrollPosition = _stopTranslate(this, choice);

            e.preventDefault();
        }, false);

        page.addEventListener('touchmove', function(e) {
            var touchobj = e.changedTouches[0];

            var newY = startTop + touchobj.pageY - startY;
            if(newY > 0) newY = 0;
            if(newY < -this.clientHeight) newY = -this.clientHeight;
            scrollPosition = _setTranslate(this, newY, choice);

            thenX = nowX;
            nowX = touchobj.pageX;
            thenY = nowY;
            nowY = touchobj.pageY;
            lastLastMoveTime = lastMoveTime;
            lastMoveTime = Date.now();

            e.preventDefault(); // prevent scrolling when inside DIV
        }, false);

        page.addEventListener('touchend', function(e) {
            var touchobj = e.changedTouches[0];
            distX = touchobj.pageX - startX; // get horizontal dist traveled by finger while in contact with surface
            distY = touchobj.pageY - startY; // get vertical dist traveled by finger while in contact with surface
            var elapsedTime = Date.now() - startTime; // get time elapsed
            var swipedir = null;
            if (elapsedTime <= allowedTime) { // first condition for awipe met
                if (Math.abs(distX) >= threshold && Math.abs(distY) <= restraint) { // 2nd condition for horizontal swipe met
                    swipedir = (distX < 0) ? 'left' : 'right'; // if dist traveled is negative, it indicates left swipe
                } else if (Math.abs(distY) >= threshold && Math.abs(distX) <= restraint) { // 2nd condition for vertical swipe met
                    swipedir = (distY < 0) ? 'up' : 'down'; // if dist traveled is negative, it indicates up swipe
                }
            }

            var endTime = Date.now();

            handleswipe(this, swipedir, elapsedTime, distX, distY, nowX - thenX, nowY - thenY, lastMoveTime - lastLastMoveTime, endTime - lastMoveTime, thresholdTime, acceleration);

            e.preventDefault();
        }, false);
    };

    var _setTranslate = function (el, d, chc) {
        var t = d || 0;
        if(t > 0) t = 0;
        else if(t < -el.clientHeight) t = -el.clientHeight;

        var tt = t;

        if(chc == 0) {
            t = 'translate3d(0,' + t + 'px,0)';
            el.style.transform = t;
            el.style.WebkitTransform = t;
        } else if(chc == 1) {
            el.style.top = t + 'px';
        }

        // console.log(tt);
        return tt;
    };

    var _calTranslate = function (s0, v, a) {
        return parseFloat(s0) + (v > 0 ? 1 : -1) * v * v / (2 * a);
    };

    var _updateTransition = function(el, v, a, p, _b0, _b1, chc) {
        if(a > 0) a = -a;
        var b0 = _b0 || 0,
            b1 = _b1 || -el.clientHeight,
            newP = _calTranslate(p, v, Math.abs(a)),
            d = 0;

        if(newP > b0) d = b0 - p;
        else if(newP < b1) d = p - b1;
        else d = Math.abs(newP - p);

        v = Math.abs(v);

        var foo = v * v + 2 * a * d;
        if(foo < 0) foo = 0;
        var time = (Math.sqrt(foo) - v) / a,
            x1 = 1/3,
            y1 = v * time / d / 3,
            x2 = x1 + 1/3,
            y2 = y1 + 1/3;

        // console.log({
        //     v0: v,
        //     a: a,
        //     t: time,
        //     s: d,
        //     p0: p,
        //     p1: newP
        // });

        if(scrollStyle) document.getElementsByTagName('head')[0].removeChild(scrollStyle);
        scrollStyle = document.createElement('style');
        scrollStyle.type = 'text/css';
        var t = 'transition:  all ' + time + 's cubic-bezier(' + x1 + ', ' + y1 + ', ' + x2 + ', ' + y2 + ');';
        t = '-webkit-' + t + t;
        scrollStyle.innerHTML = '.scroll-transition { ' + t + ' }';
        document.getElementsByTagName('head')[0].appendChild(scrollStyle);

        el.className = 'scroll-transition';

        _setTranslate(el, newP, chc);
    };

    var _stopTranslate = function(el, chc) {
        var computedStyle = window.getComputedStyle(el);
        var t;

        if(chc == 0) {
            t = computedStyle.getPropertyValue('transform');
            el.style.transform = t;
            el.style.WebkitTransform = t;

            if(t != 'none') {
                t = t.substring(t.lastIndexOf(', ') + 2, t.length - (t.endsWith('px)') ? 3 : 1));
            }
        } else if(chc == 1) {
            t = computedStyle.getPropertyValue('top');
            el.style.top = t;

            if(t != 'none') {
                t = t.substring(0, t.length - (t.endsWith('px') ? 2 : 0));
            }
        }
        if(t == 'none') {
            t = 0;
        }

        el.className = '';

        // console.log(t);
        return parseFloat(t);
    };

    window.onload = function() {
        test_addScrollContent();
        var el = document.getElementById('div1');
        swipeDetect(el, function(elem, swipedir, elapsedTime, distX, distY, lastDistX, lastDistY, lastDistTime, pauseTime, thresholdTime, acceleration) {
            if(pauseTime >= thresholdTime) return;

            // console.log('Dir: ' + swipedir);
            // console.log('DistX: ' + distX);
            // console.log('Dist: ' + distY + ', ' + elapsedTime);
            // console.log('LastDistX: ' + lastDistX);
            // console.log('LastDist: ' + lastDistY + ', ' + lastDistTime);
            // console.log('Pause: ' + pauseTime);

            switch (swipedir) {
                case 'up':
                    //console.log('Speed: ' + (-distY / elapsedTime));
                    break;
                case 'down':
                    //console.log('Speed: ' + (distY / elapsedTime));
                    break;
                default:
            }

            var initialSpeed = lastDistY * 1000 / lastDistTime;

            _updateTransition(elem, initialSpeed, acceleration, scrollPosition, 0, -elem.clientHeight, choice);
        });
    };
    </script>
</head>

<body>
    <div class="scroll-wrap">
        <div id="div1" style="position:relative;left:0;"></div>
    </div>
</body>

</html>
