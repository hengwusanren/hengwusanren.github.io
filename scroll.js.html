<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Demo of Scroll.js</title>
    <style>
    html,
    body {
        height: 100%;
        padding: 0;
        margin: 0;
        border: 0;
    }

    .scroll-wrap {
        position: relative;
        height: 100%;
        border: 1px solid #000;
        overflow: hidden;
    }

    .test-div {
        height: 256px;
        line-height: 64px;
        font-size: 32px;
        border: 1px solid #666;
    }
    </style>
    <script>
    var choice = 1; // 0: transform, 1: top

    var addScrollContentForTest = function() {
        var div1 = document.getElementById('div1');
        for (var i = 0; i < 1000; i++) {
            var child = document.createElement('div');
            child.className = 'test-div';
            child.innerHTML = i;
            div1.appendChild(child);
        }
    };

    var swipeDetect = function(el, callback) {
        var page = el,
            swipedir,
            startX,
            startY,
            startTop,
            thenX, thenY, nowX, nowY,
            lastMoveTime,
            lastLastMoveTime,
            endTime,
            distX,
            distY,
            threshold = 150, //required min distance traveled to be considered swipe
            restraint = 100, // maximum distance allowed at the same time in perpendicular direction
            allowedTime = 300, // maximum time allowed to travel that distance
            thresholdTime = 100,
            acceleration = 12000,
            elapsedTime,
            startTime,
            handleswipe = callback || function() {};

        page.addEventListener('touchstart', function(e) {
            translateStop(this);

            var touchobj = e.changedTouches[0];
            swipedir = 'none';
            dist = 0;
            startX = touchobj.pageX;
            startY = touchobj.pageY;

            thenX = nowX = startX;
            thenY = nowY = startY;
            startTime = lastLastMoveTime = lastMoveTime = Date.now();
            console.log('touchstart: ' + startTime);

            // startTop = parseFloat(this.getAttribute('transform'));
            startTop = parseFloat(scrollPosition);

            e.preventDefault();
        }, false);

        page.addEventListener('touchmove', function(e) {
            var touchobj = e.changedTouches[0];

            var newPos = startTop + touchobj.pageY - startY;
            if(newPos > 0) newPos = 0;
            if(newPos < -this.clientHeight) newPos = -this.clientHeight;
            translateUpdate(this, newPos, true);

            // console.log('touchmoving');

            thenX = nowX;
            nowX = touchobj.pageX;
            thenY = nowY;
            nowY = touchobj.pageY;
            lastLastMoveTime = lastMoveTime;
            lastMoveTime = Date.now();

            e.preventDefault(); // prevent scrolling when inside DIV
        }, false);

        page.addEventListener('touchend', function(e) {
            var touchobj = e.changedTouches[0];
            distX = touchobj.pageX - startX; // get horizontal dist traveled by finger while in contact with surface
            distY = touchobj.pageY - startY; // get vertical dist traveled by finger while in contact with surface
            elapsedTime = Date.now() - startTime; // get time elapsed
            if (elapsedTime <= allowedTime) { // first condition for awipe met
                if (Math.abs(distX) >= threshold && Math.abs(distY) <= restraint) { // 2nd condition for horizontal swipe met
                    swipedir = (distX < 0) ? 'left' : 'right'; // if dist traveled is negative, it indicates left swipe
                } else if (Math.abs(distY) >= threshold && Math.abs(distX) <= restraint) { // 2nd condition for vertical swipe met
                    swipedir = (distY < 0) ? 'up' : 'down'; // if dist traveled is negative, it indicates up swipe
                }
            }

            endTime = Date.now();
            console.log('touchend: ' + endTime);

            // setTimeout(function() {handleswipe(this, swipedir, elapsedTime, distX, distY, nowX - thenX, nowY - thenY, lastMoveTime - lastLastMoveTime, endTime - lastMoveTime, thresholdTime, acceleration);}.bind(this), 0);
            handleswipe(this, swipedir, elapsedTime, distX, distY, nowX - thenX, nowY - thenY, lastMoveTime - lastLastMoveTime, endTime - lastMoveTime, thresholdTime, acceleration);

            e.preventDefault();
        }, false);
    };

    var translateUpdate = function(el, d, abs, a) {
        var t;
        if(abs) t = d;
        else {
            // t = parseFloat(el.getAttribute('transform')) + (d > 0 ? 1 : -1) * d * d / (2 * a);
            t = parseFloat(scrollPosition) + (d > 0 ? 1 : -1) * d * d / (2 * a);
        }
        if(t > 0) t = 0;
        if(t < -el.clientHeight) t = -el.clientHeight;
        // el.setAttribute('transform', t);
        scrollPosition = t;

        if(choice == 0) {
            t = 'translate(0,' + t + 'px)';
            el.style.transform = t;
            el.style.WebkitTransform = t;
            // el.style.MozTransform = t;
            // el.style.OTransform = t;
        } else if(choice == 1) {
            el.style.top = t + 'px';
        }
    };

    var scrollPosition = 0;

    var translateStop = function(el) {
        var computedStyle = window.getComputedStyle(el);

        if(choice == 0) {
            t = computedStyle.getPropertyValue('transform');
            el.style.transform = t;
            el.style.WebkitTransform = t;
            // el.style.MozTransform = t;
            // el.style.OTransform = t;

            if(t != 'none') {
                t = t.substring(t.lastIndexOf(', ') + 2, t.length - (t.endsWith('px)') ? 3 : 1));
            }
        } else if(choice == 1) {
            t = computedStyle.getPropertyValue('top');
            el.style.top = t;

            if(t != 'none') {
                t = t.substring(0, t.length - (t.endsWith('px') ? 2 : 0));
            }
        }

        el.className = '';
        // el.classList.remove('scroll-transition');
        scrollPosition = t;
    };

    var scrollStyle = null;

    window.onload = function() {
        addScrollContentForTest();
        var el = document.getElementById('div1');
        swipeDetect(el, function(elem, swipedir, elapsedTime, distX, distY, lastDistX, lastDistY, lastDistTime, pauseTime, thresholdTime, acceleration) {
            // console.log('Dir: ' + swipedir);
            // console.log('DistX: ' + distX);
            // console.log('Dist: ' + distY + ', ' + elapsedTime);
            // console.log('LastDistX: ' + lastDistX);
            console.log('LastDist: ' + lastDistY + ', ' + lastDistTime);
            console.log('Pause: ' + pauseTime);
            switch (swipedir) {
                case 'up':
                    //console.log('Speed: ' + (-distY / elapsedTime));
                    break;
                case 'down':
                    //console.log('Speed: ' + (distY / elapsedTime));
                    break;
                default:
            }

            var initialSpeed = lastDistY * 1000 / lastDistTime;
            console.log('InitialSpeed: ' + initialSpeed + ' px/s');

            if(scrollStyle) document.getElementsByTagName('head')[0].removeChild(scrollStyle);
            scrollStyle = document.createElement('style');
            scrollStyle.type = 'text/css';
            var moveDuration = Math.abs(initialSpeed) / acceleration;
            console.log('ComputedDuration: ' + moveDuration);
            var t = 'transition:  all ' + moveDuration + 's cubic-bezier(.33, .67, .67, 1);';
            t = '-webkit-' + t + '-moz-' + t + '-o-' + t + t;
            scrollStyle.innerHTML = '.scroll-transition { ' + t + ' }';
            document.getElementsByTagName('head')[0].appendChild(scrollStyle);
            // elem.classList.add('scroll-transition');
            elem.className = 'scroll-transition';
            if(pauseTime < thresholdTime) translateUpdate(elem, initialSpeed, false, acceleration);
        });
    };
    </script>
</head>

<body>
    <div class="scroll-wrap">
        <div id="div1" style="position:relative"></div>
    </div>
</body>

</html>
